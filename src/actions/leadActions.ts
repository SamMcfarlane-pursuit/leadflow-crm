"use server";

import { PrismaClient, Prisma } from '@prisma/client';
import { revalidatePath } from 'next/cache';
import { Lead, SessionData, PipelineStage } from '@/types';

const prisma = new PrismaClient();

// Omit ID and Timestamp as they are generated by DB
export type CreateLeadData = Omit<Lead, 'id' | 'timestamp' | 'actions' | 'logs'> & {
    session?: SessionData;
};

export async function createLead(data: CreateLeadData) {
    try {
        const lead = await prisma.lead.create({
            data: {
                email: data.email,
                phone: data.phone,
                revenue: data.revenue,
                businessName: data.businessName,
                tier: data.tier,
                temperature: data.temperature,
                score: data.score,
                dncStatus: data.dncStatus,
                pipelineStage: data.pipelineStage || 'New',
                state: data.state || null,
                session: data.session ? JSON.stringify(data.session) : null,
                actions: {
                    create: {
                        type: 'LEAD_CREATED',
                        status: 'SUCCESS',
                        message: 'Lead created via manual entry'
                    }
                },
                logs: {
                    create: {
                        level: 'INFO',
                        message: 'Lead entered into system',
                        module: 'CORE'
                    }
                }
            }
        });
        revalidatePath('/dashboard');
        revalidatePath('/pipeline');
        return { success: true, lead };
    } catch (error) {
        console.error('Failed to create lead:', error);
        return { success: false, error: 'Failed to create lead' };
    }
}

// ─── BULK INSERT (20K scale) ─────────────────────────────────────────
export type BulkLeadData = {
    email: string;
    phone: string;
    revenue: number;
    businessName: string;
    tier: string;
    temperature: string;
    score: number;
    dncStatus: string;
    pipelineStage?: string;
    state?: string;
    industry?: string;
    contactName?: string;
};

export async function bulkCreateLeads(leads: BulkLeadData[]) {
    try {
        const result = await prisma.$transaction(async (tx) => {
            // Use createMany for maximum throughput (no nested creates)
            const created = await tx.lead.createMany({
                data: leads.map(l => ({
                    email: l.email,
                    phone: l.phone,
                    revenue: l.revenue,
                    businessName: l.businessName,
                    tier: l.tier,
                    temperature: l.temperature,
                    score: l.score,
                    dncStatus: l.dncStatus,
                    pipelineStage: l.pipelineStage || 'New',
                    state: l.state || null,
                    industry: l.industry || null,
                    contactName: l.contactName || null,
                    session: null,
                })),
            });
            return created.count;
        });

        revalidatePath('/dashboard');
        revalidatePath('/pipeline');
        return { success: true, count: result };
    } catch (error) {
        console.error('Bulk insert failed:', error);
        return { success: false, error: 'Bulk insert failed', count: 0 };
    }
}

// ─── PAGINATED FETCH (server-side search/filter) ─────────────────────
export type LeadFilters = {
    search?: string;
    temperature?: string;
    minScore?: number;
    pipelineStage?: string;
};

export async function getLeadsPaginated(
    page: number = 1,
    pageSize: number = 50,
    filters?: LeadFilters
) {
    try {
        const where: Prisma.LeadWhereInput = {};

        if (filters?.search) {
            where.OR = [
                { businessName: { contains: filters.search } },
                { email: { contains: filters.search } },
                { state: { contains: filters.search } },
                { phone: { contains: filters.search } },
            ];
        }
        if (filters?.temperature && filters.temperature !== 'All') {
            where.temperature = filters.temperature;
        }
        if (filters?.minScore) {
            where.score = { gte: filters.minScore };
        }
        if (filters?.pipelineStage) {
            where.pipelineStage = filters.pipelineStage;
        }

        const [leads, total] = await Promise.all([
            prisma.lead.findMany({
                where,
                orderBy: { timestamp: 'desc' },
                skip: (page - 1) * pageSize,
                take: pageSize,
            }),
            prisma.lead.count({ where }),
        ]);

        const mappedLeads: Lead[] = leads.map(l => ({
            ...l,
            state: l.state ?? undefined,
            industry: l.industry ?? undefined,
            contactName: l.contactName ?? undefined,
            session: l.session ? JSON.parse(l.session) : undefined,
            actions: [],
            pipelineStage: l.pipelineStage as PipelineStage,
            tier: l.tier as any,
            temperature: l.temperature as any,
            dncStatus: l.dncStatus as any,
            logs: [],
        }));

        return {
            success: true,
            leads: mappedLeads,
            total,
            page,
            pageSize,
            totalPages: Math.ceil(total / pageSize),
        };
    } catch (error) {
        console.error('Failed to fetch paginated leads:', error);
        return { success: false, leads: [], total: 0, page: 1, pageSize, totalPages: 0 };
    }
}

// ─── AGGREGATED STATS (no full fetch needed) ─────────────────────────
export async function getLeadStats() {
    try {
        const [total, hotCount, warmCount, coldCount, avgScore, totalRevenue] = await Promise.all([
            prisma.lead.count(),
            prisma.lead.count({ where: { temperature: 'Hot' } }),
            prisma.lead.count({ where: { temperature: 'Warm' } }),
            prisma.lead.count({ where: { temperature: 'Cold' } }),
            prisma.lead.aggregate({ _avg: { score: true } }),
            prisma.lead.aggregate({ _sum: { revenue: true } }),
        ]);

        return {
            success: true,
            stats: {
                total,
                hot: hotCount,
                warm: warmCount,
                cold: coldCount,
                lukewarm: total - hotCount - warmCount - coldCount,
                avgScore: Math.round(avgScore._avg.score || 0),
                totalRevenue: totalRevenue._sum.revenue || 0,
            }
        };
    } catch (error) {
        console.error('Failed to get stats:', error);
        return { success: false, stats: null };
    }
}

// ─── LEGACY (keep for backward compat) ───────────────────────────────
export async function getLeads() {
    try {
        const prismaLeads = await prisma.lead.findMany({
            orderBy: { timestamp: 'desc' },
            include: { logs: true }
        });

        const leads: Lead[] = prismaLeads.map(l => ({
            ...l,
            state: l.state ?? undefined,
            industry: l.industry ?? undefined,
            contactName: l.contactName ?? undefined,
            session: l.session ? JSON.parse(l.session) : undefined,
            actions: [],
            pipelineStage: l.pipelineStage as PipelineStage,
            tier: l.tier as any,
            temperature: l.temperature as any,
            dncStatus: l.dncStatus as any,
            logs: l.logs.map(log => ({
                ...log,
                level: log.level as any,
                module: log.module as any
            }))
        }));

        return { success: true, leads };
    } catch (error) {
        console.error('Failed to fetch leads:', error);
        return { success: false, error: 'Failed to fetch leads' };
    }
}

export async function updateLeadStage(leadId: string, stage: string) {
    try {
        await prisma.lead.update({
            where: { id: leadId },
            data: {
                pipelineStage: stage,
                logs: {
                    create: {
                        level: 'INFO',
                        message: `Lead moved to ${stage}`,
                        module: 'PIPELINE'
                    }
                }
            }
        });
        revalidatePath('/pipeline');
        revalidatePath('/dashboard');
        return { success: true };
    } catch (error) {
        console.error('Failed to update lead stage:', error);
        return { success: false, error: 'Failed to update lead stage' };
    }
}

// --- RESCORE: Recalculate all leads with unified scoring ---
export async function rescoreAllLeads() {
    const { calculateTier } = await import('@/utils/ironGateLogic');

    const leads = await prisma.lead.findMany({ select: { id: true, revenue: true } });
    let updated = 0;

    for (const lead of leads) {
        const { tier, temperature, score } = calculateTier(lead.revenue);
        await prisma.lead.update({
            where: { id: lead.id },
            data: { tier, temperature, score },
        });
        updated++;
    }

    revalidatePath('/dashboard');
    revalidatePath('/pipeline');
    revalidatePath('/analytics');
    return { updated };
}
